# Preprocessor Directives

Preprocessor directives are lines included in the code of programs preceded by a hash sign (#). These lines are not program statements but directives for the preprocessor. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements. They can be used to include headers or other source files, conditional compilation of blocks of code, define small inline functions (macros), alter how the compiler handles variables and parameter passing and other uses.

| Name       | Description |
| ---------- | ----------- |
| [#alert](#alert) | Generates a compiler message (like an error). |
| [#assign](#assign) | Emulates the C convention for the `=` operator. |
| [#autodim](#autodim) | Enables variables to be created without a `dim` statement. |
| [#blockdepth](#blockdepth) | Returns the nesting depth of a block. |
| [#byref](#byref) | Specifies that parameters must be passed using its address instead of its value. |
| [#byval](#byval) | Specifies that parameters must be passed by value instead of by reference. |
| [#case](#case) | Specifies the case sensitivity mode. |
| [#compact](#compact) | Removes unused code. |
| [#console](#console) | Prevents the creation of a new console. |
| [#cpointer](#cpointer) | Specifies to use C-like syntax with pointers. |
| [#def](#def) | Defines a low level macro. |
| [#define](#define) | Defines a preprocessor macro. |
| [#dim](#dim) | Specifies the datatype to be used when this is unspecified. |
| [#else](#else) | Preprocessor conditional directive. |
| [#elseif](#elseif) | Preprocessor conditional directive. |
| [#endif](#endif) | Ends a group of conditional directives. |
| [#endv](#endv) | Creates a window for compiler listings. |
| [#error](#error) | Generates a compiler error message. |
| [#file](#file) | Specifies a filename for compiled code (.EXE or .DLL). |
| [#if](#if) | Preprocessor conditional directive. |
| [#ifdef](#ifdef) | Preprocessor conditional directive. |
| [#ifndef](#ifndef) | Preprocessor conditional directive. |
| [#include](#include) | Includes source code from another file. |
| [#lookahead](#lookahead) | Tells the compiler to internally create header declarations for all procedures. |
| [#noinit](#noinit) | Prevents variables from being automatically initialised to nul within a procedure. |
| [#noprec](#noprec) | Directive to evaluate an expression from left to right, ignoring standard operator precedence rule. |
| [#pragma](#pragma) | Ignored C-style directive. |
| [#print](#print) | Displays a constant expression during compilation. |
| [#recordof](#recordof) | Returns the internal record of a declared entity. |
| [#semicolon](#semicolon) | Switch use of semicolon as comment marker or separator. |
| [#show](#show) | Displays the translated assembler code of a statement during compilation. |
| [#undef](#undef) | Removes a previously defined symbol. |
| [#undefine](#undefine) | Removes a previously defined symbol. |
| [#unique](#unique) | Prevents symbols from being redefined. |
| [#view](#view) | Creates a window for compiler listings. |

# <a name="#alert"></a>#alert

Generates a compiler message (like an error).

Used to alert programmer about an area of code that requires attention.

#### Example

```
#alert (please implement methods for this interface)
```

# <a name="#assign"></a>#assign

Emulates the C convention for the `=` operator.

When `assign` is on, `=` acts always as an assignment operator in conditional statements and `==` must be used to test equality.
 
#### Example

```
#assign on
if hresult = QueryInterface(gu, ob) then ...
```

# <a name="#autodim"></a>#autodim

Enables variables to be created without a `dim` statement. The type is implied from the initializer expression.

#### Example

```
#autodim on
v = 123
print v
```

# <a name="#blockdepth"></a>#blockdepth

Returns the nesting depth of a block at compile time.

This command was introduced to catch unclosed blocks which are often hard to trace.

#### Example

```
#blockdepth node x   ' use any descriptive label on the line
```

# <a name="#byref"></a>#byref

Specifies that parameters must be passed using its address instead of its value.

#### Example

```
#byref on
```

# <a name="#byval"></a>#byval

Specifies that parameters must be passed by value instead of by reference.

#### Example

```
#byval on
```

# <a name="#case"></a>#case

Specifies the case sensitivity mode: `sensitive`, `insensitive`, or `capital`.

`#case insensitive`  ' Treats upper- and lowercase keywords, structures and variables as being the same.<br>
`#case sensitive`    ' No case conversion, like the C language<br>
`#case capital`      ' Treats keywords, structures and variables as being lowercase, except for all-uppercase words.

`#case` has block scope and reverts to its previous state when the block ends.
 
#### Example

```
#case sensitive
```

# <a name="#compact"></a>#compact

Removes unused unused methods from classes, as well as unused general functions.

#### Example

```
#compact on
```

# <a name="#console"></a>#console

Prevents the creation of a new console. Inputs and outputs will use the existing console.

#### Example

```
#console
```

Programs compiled to EXE/DLL will run in an existing console (MS Subsystem 3) 
 
#### Remark

When Oxygen is embedded it will use the host's subsystem.


# <a name="#cpointer"></a>#cpointer

Specifies to use C-like syntax with pointers.

#### Example

Wrapping code between `#cpointer on` and `#cpointer off` directives allows to use explicit pointers that are deferenced with the `*` operator:

```
#cpointer on
dim x as long = 123456
dim p as long ptr = @x
print *p
#cpointer off
```

instead of:

```
dim x as long = 123456
dim p as long ptr
@p = @x
print p
```

or:

```
dim x as long = 123456
dim p as long = @x
print *p
```

By default, Oxygen Basic uses a novelty syntax style to avoid the use of explicit pointers. This applies uniformly to objects, functions and variables. Also to COM objects. Once an indirect variable is given an address, no further pointer notation is required.

The principle is that once an indirect variable is provided with an address, it is treated just like a normal variable. This is exactly how byref parameters work within functions for most basics.

# <a name="#def"></a>#def

Defines a low level macro. `#def` and `def` are the same.

#### Example

```
#def show "%1: " %1
int x = 123
print show x
```

# <a name="#define"></a>#define

Defines a preprocessor macro.

#### Syntax

```
#define identifier replacement
```

When the preprocessor encounters this directive, it replaces any occurrence of identifier in the rest of the code by replacement. This replacement can be an expression, a statement, a block or simply anything.

#### Example

```
#define x 32
#define False 0
#define True (not False)
```

Defines are scoped; they are only visible in the scope they were defined in.

#### Example

```
#define x 45

scope
#define x 32
   print x   ' output: 32
end scope

print x   ' output: 45
```

# <a name="#dim"></a>#dim

Specifies the datatype to be used when this is unspecified.

#### Example

```
#dim float
```

The type (or class) must be defined already.

# <a name="#else"></a>#else

Preprocessor conditional directive.

#### Syntax

```
#if (expression)
   ' Conditionally included statements if expression is True
#else
   ' Conditionally included statements if expression is False 
#endif
```

#### Example

Define LPTSTR as an LPWSTR if UNICODE is defined, an LPSTR otherwise.

```
#ifdef UNICODE
 typedef LPWSTR LPTSTR;
#else
 typedef LPSTR LPTSTR;
#endif
```

Define LONG_PTR as a long if we are compiling to 32-bit or as quad if we are compiling to 64 bit.

```
#ifndef mode64bit
   typedef long LONG_PTR;
#else
   typedef quad LONG_PTR;
#endif
```

# <a name="#elseif"></a>#elseif

Preprocessor conditional directive.

#### Syntax

```
#if (expression1)
  ' Conditionally included statements if expression1 is True
#elseif (expression2)
  ' Conditionally included statements if expression2 is True
#else
  ' Conditionally included statements if both
  ' expression1 and expression2 are False
#endif
```

#### Example

```
#ifdef mode32bit
   typedef long LONG_PTR;
#elseif mode64bit
   typedef quad LONG_PTR;
#endif
```

# <a name="#endif"></a>#endif

Ends a group of conditional directives.

#### Syntax

```
#if (expression1)
  ' Conditionally included statements if expression1 is True
#elseif (expression2)
  ' Conditionally included statements if expression2 is True
#else
  ' Conditionally included statements if both
  ' expression1 and expression2 are False
#endif
```

#### Example

```
#ifdef mode32bit
   typedef long LONG_PTR;
#elseif mode64bit
   typedef quad LONG_PTR;
#endif
```

# <a name="#endv"></a>#endv

Creates a window for compiler listings, allowing the programmer to see a selected part of the compiled code.
 
#### Example
```
sys a, b, c
###
a = b + c
###
string s = "Value " + str(a)
```

The `###` markers restrict the listing to a window so that the code can be studied in detail.

`#view` and `#endv` are generated internally from the pair of `###` symbols.

# <a name="#error"></a>#error

Generates a compiler error message.

Used to alert the programmer about inconsistencies that require attention. 

#### Example

```
#error (please implement methods for this interface)
```

# <a name="#file"></a>#file

Specifies a filename for compiled code (.EXE or .DLL).

#### Example

```
#file "test.exe"
#file "myDll.dll"
```

# <a name="#if"></a>#if

Preprocessor conditional directive.

Statements contained within the `#if / #endif` block are included if expression evaluates to true (non-zero) and excluded (ignored) if expression evaluates to false (0).

```
#define DEBUG_LEVEL 1
#if (DEBUG_LEVEL >= 2)
  ' This line is not compiled since the expression is false
  OutputDebugString ("expression")
#endif
```

# <a name="#ifdef"></a>#ifdef

Preprocessor conditional directive.

Include code if symbol already defined.

#### Example

Define LPTSTR as an LPWSTR if UNICODE is defined, an LPSTR otherwise.

```
#ifdef UNICODE
 typedef LPWSTR LPTSTR;
#else
 typedef LPSTR LPTSTR;
#endif
```

# <a name="#ifndef"></a>#ifndef

Preprocessor conditional directive.

Include code if symbol is not defined.

#### Example

Define LONG_PTR as a long if we are compiling to 32-bit or as quad if we are compiling to 64 bit.

```
#ifndef mode64bit
   typedef long LONG_PTR;
#else
   typedef quad LONG_PTR;
#endif
```

# <a name="#include"></a>#include

Includes source code from another file. `#include` and `include` are the same.

#### Syntax

```
#include [once] "file"
```

#### Example

```
#include "rtl32.inc"
```

The `once` specifier instructs the compiler to include the file only once even if it is included several times by the source code.

# <a name="#lookahead"></a>#lookahead

Tells the compiler to internally create header declarations for all procedures, allowing forward referenced procedure calls.

#### Example

```
#lookahead
f "ok"
'...
sub f (s as string)
  print s
end sub
```

Procedures in inner blocks are ignored, so each block must have its own `#lookahead`.

# <a name="#noinit"></a>#noinit

Prevents variables from being automatically initialised to nul within a procedure.

#### Example

```
#noinit
```

# <a name="#noprec"></a>#noprec

Directive to evaluate an expression from left to right, ignoring standard operator precedence rule.

#### Example

```
function my_log (float v) as float
   static double k1 = 0.69314718
   static double k2 = 126.94269504
   float y = (int) v
   'return k1 * (y*ishift - k2) ' with standard operator precedence
   #noprec return y * ishift - k2 * k1
end function
```

# <a name="#pragma"></a>#pragma

Ignored C-style directive.

C compilers use it for platform or compiler-specific mode changes.
 
```
#pragma warning(push)
```

# <a name="#print"></a>#print
 
Displays a constant expression during compilation.

#### Example

```
#print "Not implemented"
```

# <a name="#recordof"></a>#recordof

Returns the internal record of a declared entity.

#### Example

```
#recordof MyStructure
```

This command was introduced to aid debugging at compile time.


# <a name="#semicolon"></a>#semicolon

Switch use of semicolon as comment marker or separator.

It can be confined to a scope (function, etc.).

#### Example

```
#semicolon separator
s="ok"  ; print s
#semicolon comment
print "ok" ; this is a comment
```

# <a name="#show"></a>#show

Displays the translated assembler code of a statement during compilation.

Allows the programmer to see a selected part of the compiled code.
 
```
sys a, b, c
#show a = b + c 'display coding in a messagebox
```

# <a name="#undef"></a>#undef

Undefines a symbol previously defined with `#define`.

#### Syntax

```
#undef <symbol name>
```

```
#define x 32
...
#undef x
```

# <a name="#undefine"></a>#undefine

Undefines a symbol previously defined with `#define`.

#### Syntax

```
#undefine <symbol name>
```

```
#define x 32
...
#undefine x
```

# <a name="#unique"></a>#unique

Prevents symbols from being redefined.

Flags an error if a a symbol definition is not unique (in the same nesting level).

```
#unique on
#unique off 'default
```
```
#unique enabled
#unique disabled 'default
```

#### Example

If the `#unique`directive is enabled, the code below display an error message saying that 'x' is already defined.

```
#unique on
dim x as long = 123
dim x as int = 456
print x
```

Without it, 'x' is redefined as an `int` with a new value.

```
#unique on
dim x as long = 123
dim x as int = 456
print x
```

# <a name="#view"></a>#view

Creates a window for compiler listings, allowing the programmer to see a selected part of the compiled code.
 
#### Example
```
sys a, b, c
###
a = b + c
###
string s = "Value " + str(a)
```

The `###` markers restrict the listing to a window so that the code can be studied in detail.

`#view` and `#endv` are generated internally from the pair of `###` symbols.
